<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cache & Performance Exploits (My Courses â€¢ Red Team â€¢ Web Hacking)</title>
  <link rel="stylesheet" href="https://myfirstorlastname.github.io/whoami/style.css" />
</head>
<body>
  <div id="toc-container"></div>

  <h1>âš¡ Cache & Performance Exploits (My Courses)</h1>
  <blockquote>"When performance shortcuts meet weak validation, caches become weapons."</blockquote>
  <hr>

  <h2>ğŸ§  About</h2>
  <p>
    Modern web applications rely on caching systems to <strong>speed up responses</strong> and reduce backend load.
    However, when cache layers are misconfigured or trust unvalidated data, attackers can <strong>poison responses</strong>
    or <strong>bypass protections</strong> to gain unauthorized access.  
  </p>
  <p>
    This section introduces two major attack classes:
    <strong>Web Cache Deception</strong> and <strong>Web Cache Poisoning</strong>.  
    Both highlight the tension between <em>performance optimization</em> and <em>security guarantees</em>.
  </p>
  <hr>

  <h2>ğŸ—‚ï¸ Course Modules</h2>
  <div class="grid-container">
    <a class="card" href="./Web Cache Deception">
      <h3>ğŸ­ Web Cache Deception</h3>
      <p>Tricking caches into storing and serving sensitive content (e.g., authenticated pages).</p>
    </a>

    <a class="card" href="./Web Cache Poisoning">
      <h3>â˜ ï¸ Web Cache Poisoning</h3>
      <p>Injecting malicious payloads into cached responses to affect multiple users.</p>
    </a>
  </div>
  <hr>

  <h2>ğŸ“˜ Why Cache Exploits Matter</h2>
  <ul>
    <li>Caches sit at the edgeâ€”any poisoning or deception attack has a <strong>wide blast radius</strong>.</li>
    <li>They often <strong>trust headers, query strings, or cookies</strong> without validation.</li>
    <li>Subtle quirks (normalization, fat GET requests, unkeyed params) can collapse isolation.</li>
    <li>Attackers can steal sensitive content, inject malicious scripts, or bypass authentication entirely.</li>
  </ul>
  <hr>

  <h2>ğŸ¯ Beginner Playbook</h2>
  <ul>
    <li><strong>Web Cache Deception:</strong> Append fake extensions (<code>/profile.php/fake.css</code>) to trick caches into storing dynamic pages.</li>
    <li><strong>Web Cache Poisoning:</strong> Manipulate headers (<code>X-Forwarded-Host</code>, <code>X-Original-URL</code>), query params, or cookies to poison cache entries.</li>
    <li>Test both <strong>reflected payloads</strong> (affecting a single response) and <strong>persistent poisoning</strong> (affecting future users).</li>
  </ul>
  <hr>

  <h2>ğŸ›¡ï¸ Defense Mindset</h2>
  <ul>
    <li>Canonicalize and strictly validate cache keys (headers, params, cookies).</li>
    <li>Do not cache authenticated or dynamic content without explicit, safe rules.</li>
    <li>Segment caches for authenticated vs. anonymous traffic.</li>
    <li>Log anomalies (unexpected headers, strange extensions, fat GETs).</li>
  </ul>
  <hr>

  <h2>âœ… Key Takeaways</h2>
  <ul>
    <li>Performance optimization can <strong>weaken security boundaries</strong> if not carefully designed.</li>
    <li>Cache deception threatens <strong>confidentiality</strong> (stealing data), while cache poisoning targets <strong>integrity</strong> (malicious payloads).</li>
    <li>Both are high-impact and often overlooked in penetration tests.</li>
  </ul>
  <hr>

  <footer>
    <p>"Fast isnâ€™t safeâ€”unless the cache is guarded."</p>
  </footer>

  <script src="https://myfirstorlastname.github.io/whoami/call_for_toc.js"></script>
</body>
</html>
