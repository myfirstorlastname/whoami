<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HTTP Request Smuggling (TryHackMe : Web Application Pentesting path)</title>
  <link rel="stylesheet" href="https://myfirstorlastname.github.io/whoami/style.css" />
</head>
<body>
  <div id="toc-container"></div>
  
  <h1>âš”ï¸ HTTP Request Smuggling (TryHackMe : Web Application Pentesting path)</h1>
  <blockquote>"When front-end and back-end servers disagree, the attacker decides what request they see."</blockquote>
  <hr>

  <h2>ğŸ§  About</h2>
  <p>
    This page documents my completion of the 
    <a href="https://tryhackme.com/module/http-request-smuggling" target="_blank" rel="noopener noreferrer">"HTTP Request Smuggling"</a> 
    module, part of the <em>Web Application Pentesting</em> learning path on TryHackMe.  
    Request smuggling is a subtle yet devastating vulnerability that exploits <strong>inconsistent parsing of HTTP requests</strong> between front-end and back-end servers.
  </p>
  <p>
    By carefully crafting conflicting headers or malformed requests, an attacker can â€œsmuggleâ€ hidden requests past security controls.  
    This module demonstrates how such desynchronization can lead to cache poisoning, hijacking, and full application compromise.
  </p>
  <hr>

  <h2>ğŸ›°ï¸ Philosophy</h2>
  <blockquote>"Desync attacks turn tiny parsing ambiguities into full control of the HTTP pipeline."</blockquote>
  <ul>
    <li>Even mature protocols like HTTP hide complex edge cases that attackers exploit.</li>
    <li>Request smuggling is less about brute force and more about precisionâ€”understanding how different servers interpret the same input.</li>
    <li>A single desynced request can poison caches, steal tokens, or execute actions across user sessions.</li>
  </ul>
  <hr>

  <h2>ğŸ” Learning Outcomes: HTTP Request Smuggling</h2>
  <blockquote>From CL.TE to HTTP/2 desyncâ€”learning how to weaponize tiny inconsistencies in protocol parsing.</blockquote>

  <h3>ğŸ“˜ Module Summary</h3>
  <ul>
    <li><strong>HTTP Request Smuggling</strong>  
      Introduced the basics of smuggling using mismatched <code>Content-Length</code> and <code>Transfer-Encoding</code> headers (CL.TE, TE.CL).  
      Demonstrated how a hidden request can slip past the front-end proxy and reach the back-end unaltered.</li>
    <li><strong>HTTP/2 Request Smuggling</strong>  
      Showed how protocol downgrades or inconsistent implementations in HTTP/2 create new smuggling vectors.  
      Highlighted how modern infrastructures are still vulnerable despite protocol upgrades.</li>
    <li><strong>Request Smuggling: WebSockets</strong>  
      Explored smuggling in the context of WebSocket upgrade requests. By manipulating handshake boundaries, attackers could hijack persistent connections.</li>
    <li><strong>HTTP Browser Desync</strong>  
      Illustrated how smuggling can extend to browsers themselves, causing user agents to misinterpret or desync requests.  
      This opened the door to advanced client-side exploitation chains.</li>
    <li><strong>El Bandito (Challenge)</strong>  
      A final practical lab combining multiple smuggling techniques. Required chaining protocol ambiguities, cache poisoning, and session hijacking into a full exploit scenario.</li>
  </ul>

  <h3>ğŸ§ª What I appreciated as an advanced learner</h3>
  <ul>
    <li>The precision requiredâ€”every header, every byte matters in request smuggling.</li>
    <li>The HTTP/2 section was particularly valuable since many guides focus only on HTTP/1.1 smuggling.</li>
    <li>The WebSocket lab bridged two domains (real-time channels and HTTP parsing), showing real-world attacker creativity.</li>
    <li>The â€œEl Banditoâ€ challenge forced me to chain concepts together, simulating an actual red-team engagement.</li>
  </ul>

  <h3>ğŸ“ Who I recommend this to</h3>
  <ul>
    <li>Pentesters aiming to deepen their web exploitation beyond OWASP Top 10 basics.</li>
    <li>Bug bounty hunters targeting high-value apps behind load balancers, CDNs, or reverse proxies.</li>
    <li>Developers and DevSecOps engineers working with complex HTTP infrastructures (proxies, WAFs, API gateways).</li>
  </ul>

  <h3>ğŸ› ï¸ My Personal Tips</h3>
  <ul>
    <li>Experiment with different header combinations (<code>CL</code>, <code>TE</code>, mixed casing, duplicates) to trigger parsing discrepancies.</li>
    <li>Use <strong>Burp Repeater</strong> and <strong>Turbo Intruder</strong> for precise control over raw HTTP requests.</li>
    <li>Always check for downstream effects: cache poisoning and session hijacking are often easier than full RCE.</li>
    <li>Donâ€™t ignore HTTP/2â€”modern infrastructures are adopting it, and vulnerabilities are under-explored.</li>
    <li>Think creatively: request smuggling is about protocol quirks, not just injections.</li>
  </ul>

  <h3>âœ… Completion Status</h3>
  <ul>
    <li><strong>Module completed: 100%</strong></li>
    <li><strong>Final thoughts:</strong> This was one of the most technical modules in the Web Application Pentesting path.  
      Mastering HTTP Request Smuggling requires patience, precision, and an understanding of protocol-level details.  
      Itâ€™s a rare but critical skill for high-impact web exploitation.</li>
  </ul>

  <hr>
  <footer style="margin-top: 3rem; font-size: 0.9rem; color: #666;">
    Tiny protocol quirks can become critical exploitsâ€”request smuggling is proof that even HTTP can be weaponized.  
  </footer>
  <script src="https://myfirstorlastname.github.io/whoami/call_for_toc.js"></script>
</body>
</html>
