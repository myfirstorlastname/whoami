<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HTTP Request Smuggling (TryHackMe : Web Application Pentesting path)</title>
  <link rel="stylesheet" href="https://myfirstorlastname.github.io/whoami/style.css" />
</head>
<body>
  <div id="toc-container"></div>
  
  <h1>⚔️ HTTP Request Smuggling (TryHackMe : Web Application Pentesting path)</h1>
  <blockquote>"When front-end and back-end servers disagree, the attacker decides what request they see."</blockquote>
  <hr>

  <h2>🧠 About</h2>
  <p>
    This page documents my completion of the 
    <a href="https://tryhackme.com/module/http-request-smuggling" target="_blank" rel="noopener noreferrer">"HTTP Request Smuggling"</a> 
    module, part of the <em>Web Application Pentesting</em> learning path on TryHackMe.  
    Request smuggling is a subtle yet devastating vulnerability that exploits <strong>inconsistent parsing of HTTP requests</strong> between front-end and back-end servers.
  </p>
  <p>
    By carefully crafting conflicting headers or malformed requests, an attacker can “smuggle” hidden requests past security controls.  
    This module demonstrates how such desynchronization can lead to cache poisoning, hijacking, and full application compromise.
  </p>
  <hr>

  <h2>🛰️ Philosophy</h2>
  <blockquote>"Desync attacks turn tiny parsing ambiguities into full control of the HTTP pipeline."</blockquote>
  <ul>
    <li>Even mature protocols like HTTP hide complex edge cases that attackers exploit.</li>
    <li>Request smuggling is less about brute force and more about precision—understanding how different servers interpret the same input.</li>
    <li>A single desynced request can poison caches, steal tokens, or execute actions across user sessions.</li>
  </ul>
  <hr>

  <h2>🔎 Learning Outcomes: HTTP Request Smuggling</h2>
  <blockquote>From CL.TE to HTTP/2 desync—learning how to weaponize tiny inconsistencies in protocol parsing.</blockquote>

  <h3>📘 Module Summary</h3>
  <ul>
    <li><strong>HTTP Request Smuggling</strong>  
      Introduced the basics of smuggling using mismatched <code>Content-Length</code> and <code>Transfer-Encoding</code> headers (CL.TE, TE.CL).  
      Demonstrated how a hidden request can slip past the front-end proxy and reach the back-end unaltered.</li>
    <li><strong>HTTP/2 Request Smuggling</strong>  
      Showed how protocol downgrades or inconsistent implementations in HTTP/2 create new smuggling vectors.  
      Highlighted how modern infrastructures are still vulnerable despite protocol upgrades.</li>
    <li><strong>Request Smuggling: WebSockets</strong>  
      Explored smuggling in the context of WebSocket upgrade requests. By manipulating handshake boundaries, attackers could hijack persistent connections.</li>
    <li><strong>HTTP Browser Desync</strong>  
      Illustrated how smuggling can extend to browsers themselves, causing user agents to misinterpret or desync requests.  
      This opened the door to advanced client-side exploitation chains.</li>
    <li><strong>El Bandito (Challenge)</strong>  
      A final practical lab combining multiple smuggling techniques. Required chaining protocol ambiguities, cache poisoning, and session hijacking into a full exploit scenario.</li>
  </ul>

  <h3>🧪 What I appreciated as an advanced learner</h3>
  <ul>
    <li>The precision required—every header, every byte matters in request smuggling.</li>
    <li>The HTTP/2 section was particularly valuable since many guides focus only on HTTP/1.1 smuggling.</li>
    <li>The WebSocket lab bridged two domains (real-time channels and HTTP parsing), showing real-world attacker creativity.</li>
    <li>The “El Bandito” challenge forced me to chain concepts together, simulating an actual red-team engagement.</li>
  </ul>

  <h3>🎓 Who I recommend this to</h3>
  <ul>
    <li>Pentesters aiming to deepen their web exploitation beyond OWASP Top 10 basics.</li>
    <li>Bug bounty hunters targeting high-value apps behind load balancers, CDNs, or reverse proxies.</li>
    <li>Developers and DevSecOps engineers working with complex HTTP infrastructures (proxies, WAFs, API gateways).</li>
  </ul>

  <h3>🛠️ My Personal Tips</h3>
  <ul>
    <li>Experiment with different header combinations (<code>CL</code>, <code>TE</code>, mixed casing, duplicates) to trigger parsing discrepancies.</li>
    <li>Use <strong>Burp Repeater</strong> and <strong>Turbo Intruder</strong> for precise control over raw HTTP requests.</li>
    <li>Always check for downstream effects: cache poisoning and session hijacking are often easier than full RCE.</li>
    <li>Don’t ignore HTTP/2—modern infrastructures are adopting it, and vulnerabilities are under-explored.</li>
    <li>Think creatively: request smuggling is about protocol quirks, not just injections.</li>
  </ul>

  <h3>✅ Completion Status</h3>
  <ul>
    <li><strong>Module completed: 100%</strong></li>
    <li><strong>Final thoughts:</strong> This was one of the most technical modules in the Web Application Pentesting path.  
      Mastering HTTP Request Smuggling requires patience, precision, and an understanding of protocol-level details.  
      It’s a rare but critical skill for high-impact web exploitation.</li>
  </ul>

  <hr>
  <footer style="margin-top: 3rem; font-size: 0.9rem; color: #666;">
    Tiny protocol quirks can become critical exploits—request smuggling is proof that even HTTP can be weaponized.  
  </footer>
  <script src="https://myfirstorlastname.github.io/whoami/call_for_toc.js"></script>
</body>
</html>
